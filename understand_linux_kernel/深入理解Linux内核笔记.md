  * [第一章 绪论](#第一章-绪论)
     * [Linux与其他类Unix内核比较](#linux与其他类unix内核比较)
     * [硬链接和软链接](#硬链接和软链接)
     * [文件类型](#文件类型)
     * [文件描述符与索引节点](#文件描述符与索引节点)
     * [访问权限和文件模式](#访问权限和文件模式)
     * [Unix内核概述](#unix内核概述)
  * [第二章 内存寻址](#第二章-内存寻址)
  * [第三章 进程](#第三章-进程)
  * [第四章 中断和异常](#第四章-中断和异常)
  * [第五章 内核同步](#第五章-内核同步)
  * [第六章 定时测量](#第六章-定时测量)
  * [第七章 进程调度](#第七章-进程调度)
  * [第八章 内存管理](#第八章-内存管理)
  * [第九章 进程地址空间](#第九章-进程地址空间)
  * [第十章 系统调用](#第十章-系统调用)
  * [第十一章 信号](#第十一章-信号)
  * [第十二章 虚拟文件系统](#第十二章-虚拟文件系统)
  * [第十三章 IO体系结构和设备驱动程序](#第十三章-io体系结构和设备驱动程序)
  * [第十四章 块设备驱动程序](#第十四章-块设备驱动程序)
  * [第十五章 页高速缓存](#第十五章-页高速缓存)
  * [第十六章 访问文件](#第十六章-访问文件)
  * [第十七章 回收页框](#第十七章-回收页框)
  * [第十八章 Ext2和Ext3文件系统](#第十八章-ext2和ext3文件系统)
  * [第十九章 进程间通信](#第十九章-进程间通信)
  * [第二十章 程序的执行](#第二十章-程序的执行)
  * [附录1 系统启动](#附录1-系统启动)
  * [附录2 模块](#附录2-模块)
     * [内存地址](#内存地址)
     * [Linux中的分页](#linux中的分页)
        * [进程页表](#进程页表)
        * [内核页表](#内核页表)
        * [临时内核页表](#临时内核页表)
        * [当RAM小于896MB时的最终内核页表](#当ram小于896mb时的最终内核页表)
        * [当RAM大小在896MB和4096MB之间时的最终内核页表](#当ram大小在896mb和4096mb之间时的最终内核页表)
        * [当RAM大于4096MB时的最终内核页表](#当ram大于4096mb时的最终内核页表)
        * [处理TLB](#处理tlb)
     * [进程](#进程)
        * [进程描述符](#进程描述符)
        * [进程状态](#进程状态)

### 第一章 绪论

![Screenshot from 2021-05-24 11-18-13](https://i.loli.net/2021/06/01/Y3DEIenMxFP9gVj.png)

#### Linux与其他类Unix内核比较

![Screenshot from 2021-05-24 11-24-24](https://i.loli.net/2021/06/01/1VbjXEHiIfmksLg.png)

![Screenshot from 2021-05-24 11-26-32](https://i.loli.net/2021/06/01/LVfzyw6ZTdOulAs.png)



Unix操作系统的设计集中反映在其文件系统

**文件**

Unix文件是以字节序列组成的信息载体，内核不解释文件的内容。从用户的观点来看，文件被组织在一个树结构的命名空间中，除了叶节点之外，树的所有节点都表示目录名。

![Screenshot from 2021-05-24 11-38-48](https://i.loli.net/2021/06/01/eDCNprmU8wvzA4c.png)



#### 硬链接和软链接

硬链接简称链接（Link），同一文件可以有几个链接，因此对应几个文件名。限制：

1.不允许用户给目录创建硬链接，因为可能会把目录树变成环形树 

2.只有在同一文件系统中的文件之间才能创建链接

软链接也成符号链接（symbolic link）克服了硬链接的限制



#### 文件类型

Unix文件有以下几种

* 普通文件
* 目录
* 符号链接
* 块设备文件
* 字符设备文件
* 管道（pipe）和命名管道（FIFO）
* 套接字（socket）



#### 文件描述符与索引节点

![Screenshot from 2021-05-24 11-43-57](https://i.loli.net/2021/06/01/ek93hERBIS7CjmX.png)

索引节点指定如下属性：

![Screenshot from 2021-05-24 11-45-32](https://i.loli.net/2021/06/01/FCG7mpxDzcZHnly.png)



#### 访问权限和文件模式

![Screenshot from 2021-05-24 11-47-46](https://i.loli.net/2021/06/02/c7DQ85wqFBSJYkj.png)

![Screenshot from 2021-05-24 11-48-07](https://i.loli.net/2021/06/02/3nDXlT4gfoGWZEh.png)



#### Unix内核概述

CPU既可以运行在用户态下，也可以运行在内核态下。

![Screenshot from 2021-05-24 13-47-52](https://i.loli.net/2021/06/02/ZCSYMeTQnoW43w6.png)



#### 进程地址空间

![Screenshot from 2021-06-02 14-24-40](https://i.loli.net/2021/06/02/XyWbJkze8PjaRIs.png)

![Screenshot from 2021-06-02 14-25-32](https://i.loli.net/2021/06/02/1lMGPACOFZv5zV9.png)



#### 同步和临界区

![Screenshot from 2021-06-02 14-26-37](https://i.loli.net/2021/06/02/DyMxqbuatJNXPOR.png)

![Screenshot from 2021-06-02 14-27-35](https://i.loli.net/2021/06/02/Janr53dIwG68mOc.png)

![Screenshot from 2021-06-02 14-29-12](https://i.loli.net/2021/06/02/bzxgjl2SCREyTNY.png)

![Screenshot from 2021-06-02 14-30-12](https://i.loli.net/2021/06/02/qk972X51dI3cbuo.png)

Unix信号（signal）提供了把系统时间报告给进程的一种机制。每种时间都有自己的信号编号，通常用一个符号常量表示，例如SIGTERM。有两种系统事件：

异步通告

​		例如，用户在终端按下中断键（通常为CTRL-C）时，即向前台进程发出中断信号SIGINT

同步错误或异常

​		例如，当进程访问内存非法地址时，内核向这个进程发送一个SIGSEGV信号

POSIX标准定义了大约20种不同的信号，其中有两种是用户自定义的，可以当作用户态下进程通信和同步的原语机制：

* 忽略该信号
* 异步地执行一个指定的过程（信号处理程序）



#### 虚拟内存

虚拟内存用途和优点

* 若干个进程可以并发执行
* 应用程序所需内存大于可用物理内存时也可以运行
* 程序只有部分代码装入内存时进程可以执行它
* 允许每个进程访问可用物理内存的子集
* 进程可以共享库函数或程序的一个单独内存映像
* 程序是可重定位的，也就是说，可以把程序放在物理内存的任何地方
* 程序员可以编写与机器无关的代码，因为他们不关心有关物理内存的组织结构



内核内存分配器（Kernel Memory Allocator，KMA）是一个子系统，他试图满足系统中所有部分对内存的请求，其中一些请求来自内核其他子系统，他们需要一些内核使用的内存，还有一些请求来自于用户程序的系统调用，用来增加用户进程的地址空间。一个好的KMA应该具备下列特点：

* 必须快。

* 必须把内存的浪费减到最少。

* 必须努力减轻内存的碎片问题。

* 必须能与其他内存管理子系统合作，以便借用和释放叶框。

几种KMA

* 资源图分配算法
* 2的幂次方空闲链表
* McKusick-Karels分配算法
* 伙伴系统
* Mach的区域分配算法
* Dynix分配算法
* Solaris的Slab分配算法



进程虚拟地址空间由以下内存区组成：

* 程序的可执行代码
* 程序的初始化数据
* 程序的未初始化数据
* 初始程序栈（即用户态栈）
* 所需共享库的可执行代码和数据
* 堆（由程序动态请求的内存）



### 第二章 内存寻址

#### 内存地址

逻辑地址（logical address）

​		每个逻辑地址都由一个段（segment）和偏移量（offset）组成，偏移量指明了从段开始的地方到实际地址之间的距离

线性地址（也称虚拟地址virtual address）

​		通常用十六进制数组表示，值得范围从0x00000000到0xffffffff

物理地址（physical address）

​		他们与从微处理器的地址引脚发送到内存总线上的电信号相对应



用户代码段	__USER_CS

用户数据段	__USER_DS

内核代码段	__KERNEL_CS

内核数据段	__KERNEL_DS



注意：因为Linux下所有段都从0x00000000开始，所以Linux下逻辑地址和线性地址是一致的，即逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的



高速缓存包含一个**硬件高速缓存内存**（hardware cache memory）和一个**高速缓存控制器**（cache controller）高速缓存内存放内存中真正的行，高速缓存控制器存放一个表项数组，每个表项数组对应高速缓存内存中的一个行。每个表项有一个标签（tag）和描述高速缓存行状态的几个标志（flag）。这个标签由一些位组成，这些位让高速缓存控制器能够辨别由这个行当前所映射的内存单元。

这种内存物理地址通常分为3组：最高几位对应标签，中间几位对应高速缓存控制器的子集索引，最低几位对应行内的偏移量。

![image-20200703203858036](https://i.loli.net/2021/06/01/fSYl1eJLvGdwrXZ.png)

当cache命中时，可以进行不同的操作，具体取决于存取类型。对于读操作，控制器从高速缓存行中选择数据并送到CPU寄存器，不需访问RAM因而节约了CPU时间。对于写操作，控制器可能采用以下两个基本策略之一，分别称之为**通写**（write-through）和**回写**（write-back）。

在通写中，控制器总是既写RAM也写高速缓存行，为了提高写的效率关闭高速缓存。

回写方式只更新高速缓存行，不改变RAM的内容，提供了更快的功效，当然，回写结束以后RAM最终必须被更新。只有当CPU执行一条要求刷新高速缓存表项的指令时，或者当一个FLUSH硬件信号产生时（通常在高速缓存不命中之后），高速缓存控制器才把高速缓存写回到RAM中。



#### Linux中的分页

Linux采用了一种同时适用于32位和64位系统的普通分页模型，四种页表分别称为：

* 页全局目录（Page Global Directory）
* 页上级目录（Page Upper Directory）
* 页中间目录（Page Middle Directory）
* 页表（Page Table）

**每个页表指向一个页框（page frame，长度为4KB或8KB）**

对于没有启用物理地址扩展的32位系统，通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。每一个进程有自己的页全局目录和自己的页表集，当发生进程切换时，Linux把cr3控制寄存器的内容保存在前一个执行进程的描述符中，然后把下一个要执行进程的描述符的值装入cr3寄存器中。



PAGE_SHIFT	指定Offset字段的位数

PMD_SHIFT	指定线性地址的Offset字段和Table字段的总位数

PUD_SHIFT	确定页上级目录项能映射的区域大小的对数

PGDIR_SHIFT	确定页全局目录项能映射的区域大小的对数

PTRS_PER_PTE，PTRS_PER_PMD，PTRS_PER_PUD，PTRS_PER_PGD	用于计算页表、页中间目录、也上级目录和页全局目录表中表项的个数

pte_t、pmd_t、pud_t、pgd_t	分别描述页表项、页中间目录项、页上级目录项和页全局目录项的格式

\_\_pte、\_\_pmd、\_\_pud、\_\_pgd、\_\_pgprot	五个类型转换宏把一个无符号整数转换成所需的类型

\_\_pte、\_\_pmd、\_\_pud、\_\_pgd、\_\_pgprot	五个类型转换宏把上面的四种特殊类型转换成无符号整数

pte_none、pmd_none、pud_none、pgd_none	如果相应的表项值为0，则产生的值为1，否则为0

set_pte、set_pmd、set_pud、set_pgd	向一个页表项中写入指定的值

pmd_bad	由函数使用并通过传入参数传递来检查页中间目录项。如果目录项指向一个不能使用的页表，也就是说，如果至少出现以下条件中的一个，则这个宏为1

* 页不在主存中（Present标志被清除）

* 页只允许读访问（Read/Write标志被清除）

* Acessed或者Dirty位被清除（对于每个现有的页表，Linux总是强制设置这些标志）




pgd_alloc(mm)	分配一个新的页全局目录，mm为内存描述符的地址

pgd_free(pgd)	释放全局目录中地址为pgd的项

pte_alloc_map(mm,pmd,addr)	接受中间目录项的地址pmd和线性地址addr作为参数，并返回与addr对应的页表项的地址

pte_alloc_kernel(mm,pmd,addr)	如果与地址addr相关的页中间目录项pmd为空，该函数分配一个新页表

pte_free(pte)	释放与页描述符指针pte相关的页表

pte_free_kernel(pte)	与上面函数等价，但由主内核页表使用

clear_page_range(mmu,start,end)	从线性地址start到end通过反复释放页表和清除页中间目录项来清除进程页表的内容



##### 进程页表

* 从0x00000000到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址
* 从0xc0000000到0xffffffff的线性地址，只有内核态的进程才能寻址

宏PAGE_OFFSET产生的值是0xc0000000，这就是进程在线性地址空间中的偏移量，也是内核生存空间的开始之处



##### 内核页表

内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录（master kernel Page Global Directory）中，系统初始化后，这组页表还从未被任何进程或任何内核线程直接使用，其作为参考模型，为系统中每个普通进程对应的页全局目录项提供参考模型。

内核初始化自己的页表分为两个阶段：

第一个阶段，内核创建一个有限的地址空间，包括内核的代码段和数据段、初始页表和用于存放动态数据结构的共128KB大小的空间。

第二个阶段，内核充分利用剩余的RAM并适当地建立分页表。



##### 临时内核页表

临时页全局目录是在内核编译过程中静态的初始化的，而临时页表是由汇编语言函数（arch/xxx/kernel/head.S）初始化的。临时页全局目录放在swapper_pg_dir变量中，此时PAE（page alloc external）尚未激活，临时页表在pg0变量处开始存放，紧接在内核未初始化的数据段后面。



##### 当RAM小于896MB时的最终内核页表

主内核页全局目录仍然保存在swapper_pg_dir变量中，它由paging_init()函数初始化。该函数进行如下操作：

1. 调用pagetable_init()适当地建立页表项
2. 把swapper_pg_dir的物理地址写入cr3控制寄存器中
3. 如果CPU支持PAE并且如果内核编译时支持PAE，则将cr4控制寄存器的PAE标志置位
4. 调用__flush_tlb_all()使TLB的所有项无效

##### 当RAM大小在896MB和4096MB之间时的最终内核页表

在这种情况下，并不把RAM全部映射到内核地址空间。Linux在初始化阶段可以做的最好的事是把一个具有896MB的RAM窗口映射到内核线性地址空间。

##### 当RAM大于4096MB时的最终内核页表

* CPU模型支持物理地址扩展（PAE）
* RAM容量大于4GB
* 内核以PAE支持来编译
* 使用三级分页模型



##### 处理TLB

处理器不能自动同步他们自己的TLB高速缓存，因为决定线性地址和物理地址之间映射何时不再有效的是内核，而不是硬件。

独立于系统的使TLB表项无效的方法

flush_tlb_all	刷新所有TLB表项	改变内核页表项时

flush_tlb_kernel_range	刷新给定线性地址范围内的所有TLB表项	更换一个范围内的内核页表项时

flush_tlb	刷新当前进程拥有的非全局页相关的所有TLB表项	执行进程切换时

flush_tlb_mm	刷新指定进程拥有的非全局页相关的所有TLB表项	创建一个新的子进程时或释放某个进程的线程

flush_tlb_range	刷新指定进程的线性地址间隔对应的TLB表项	地址间隔时

flush_tlb_pgtables	刷新指定进程中特定的相邻页表集相关的TLB表项	释放进程的一些页表时

flush_tlb_page	刷新指定进程中单个页表项相关的TLB表项	处理缺页异常时

















### 第三章 进程

#### 进程

##### 进程描述符

进程描述符都是task_struct类型结构，它的字段包含了与一个进程相关的所有信息。

![image-20200707092020149](https://i.loli.net/2021/06/01/hErYOGTSKqjNa7k.png)

进程描述符包含了四种不同类型的PID的字段，每种类型的PID需要自己的散列表。内核初始化期间动态地为4个散列表分配空间，并把它们的地址存入pid_hash数组。

Hash表的类型	字段名	说明

* PIDTYPE_PID	pid	进程的PID
* PIDTYPE_TGID 	tgid	线程组领头进程的PID
* PIDTYPE_PGID	pgrp	进程组领头进程的PID
* PIDTYPE_SID	session	会话领头进程的PID

![image-20200707092141035](https://i.loli.net/2021/06/01/H2h9g86yPLGfFuX.png)



##### 进程状态

进程描述符中的state字段描述了进程当前的状态，它由一组标志组成，每个标志描述一种可能的进程状态，且这些状态是互斥的。

**可运行状态（TASK_RUNNING）**

进程要么在CPU上运行，要么准备执行

**可中断的等待状态（TASK_INTERRUPTIBLE）**

进程被挂起（睡眠），直到某个条件为真。产生一个硬件中断，释放进程正在等待的系统资源，或传递一个信号都是可以唤醒进程的条件（把进程的状态放回到TASK_RUNNING）。

**不可中断的等待状态（TASK_UNINTERRUPTIBLE）**

与不可中断的等待状态类似，但有一个例外，把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下（进程必须等待，直到一个不能被中断的事件发生），这种状态很有用。

**暂停状态（TASK_STOPPED）**

进程的执行被暂停。当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。

**跟踪状态（TASK_TRACED）**

进程的执行已由debugger程序暂停。当一个进程被另一个进程监控时（例如debugger执行ptrace（）系统调用监控一个测试程序），任何信号都可以把这个进程置于TASK_TRACED状态。

还有两个进程状态既可以存放在进程描述符的state字段中，也可以存放在exit_state字段中。这两个状态只有当进程的执行被终止时才进入两种状态中的一种。

**僵死状态（EXIT_ZOMBIE）**

进程的执行状态被终止，但父进程还没有发布wait4()或waitpid()系统调用来返回有关死亡进程的信息。发布wait()类系统调用前内核不能丢弃包含在死亡进程描述符中的数据，因为父进程可能还需要它。

**僵死撤销状态（EXIT_DEAD）**

最终状态：由于父进程刚发出wait4()或waitpid()系统调用，因而进程由系统删除。

Linux引入了线程组的表示，一个线程组中的所有线程使用和该线程组的领头线程（thread group leader）相同的PID，也就是改组中第一个轻量级进程的PID，它被存入进程描述符的tgid字段中。getpid()系统调用返回当前进程的tgid值而不是pid的值，因此，一个多线程应用的所有线程共享相同的PID。绝大多数进程属于一个线程组，包含单一的成员：线程组的领头线程其tgid的值与pid的值相同，因而getpid()系统调用对这类进程所起的作用和一般进程是一样的。







































### 第四章 中断和异常

### 第五章 内核同步

### 第六章 定时测量

### 第七章 进程调度

### 第八章 内存管理

### 第九章 进程地址空间

### 第十章 系统调用

### 第十一章 信号

### 第十二章 虚拟文件系统

### 第十三章 IO体系结构和设备驱动程序

### 第十四章 块设备驱动程序

### 第十五章 页高速缓存

### 第十六章 访问文件

### 第十七章 回收页框

### 第十八章 Ext2和Ext3文件系统

### 第十九章 进程间通信

### 第二十章 程序的执行

### 附录1 系统启动

### 附录2 模块



---














